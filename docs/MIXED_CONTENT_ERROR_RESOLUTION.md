# Mixed Content Error Resolution

## üö® Issue Description

**Error Message:**
```
Mixed Content: The site at 'https://gprofiler.example.com/' was loaded over a secure connection,
but the file at 'https://gprofiler.example.com/api/flamegraph/download_svg?...' was redirected
through an insecure connection. This file should be served over HTTPS.
```

**Symptoms:**
- ‚úÖ JSON flamegraph data loads successfully via HTTPS
- ‚ùå SVG download fails with mixed content error
- ‚ùå Browser blocks the download completely

## üîç Root Cause Analysis

### The Problem Chain

```
Browser ‚Üí HTTPS ‚Üí Envoy (Load Balancer) ‚Üí HTTP ‚Üí Nginx ‚Üí HTTP ‚Üí FastAPI
                           ‚Üì
                   Sets: X-Forwarded-Proto: https
                           ‚Üì
Nginx ‚Üí WRONG: proxy_set_header X-Forwarded-Proto $scheme; (= "http")
                           ‚Üì
FastAPI ‚Üí Thinks request was HTTP ‚Üí Generates HTTP redirect URLs
                           ‚Üì
Browser ‚Üí Receives HTTP redirect ‚Üí Mixed Content Error!
```

### Technical Details

1. **SSL Termination**: Envoy (external load balancer) terminates HTTPS and forwards HTTP to Nginx
2. **Header Forwarding**: Envoy correctly sets `X-Forwarded-Proto: https`
3. **Nginx Misconfiguration**: Nginx overwrote this with `X-Forwarded-Proto: http` (using `$scheme`)
4. **FastAPI Unawareness**: FastAPI didn't know original request was HTTPS
5. **URL Generation**: FastAPI generated HTTP redirect URLs for downloads
6. **Browser Security**: Browser blocked HTTP redirects on HTTPS pages

## ü§î Why JSON Worked But SVG Downloads Failed

### JSON Endpoint Behavior
```python
@router.get("")
def get_flamegraph(fg_params: FGParamsModel = Depends(flamegraph_request_params)):
    response = get_flamegraph_response(fg_params)
    json_file = BytesIO(response.content)
    return StreamingResponse(json_file, media_type="text/plain")
```
- **Direct response**: No redirects involved
- **Content-based**: Returns data directly without URL generation
- **No mixed content**: Browser receives HTTPS response with data

### SVG Download Endpoint Behavior
```python
@router.get("/download_svg")
def get_flamegraph_svg(fg_params: FGParamsModel = Depends(flamegraph_request_params)):
    mimetype = "application/octet-stream"
    svg_file_name = get_file_name(fg_params.start_time, fg_params.end_time, fg_params.service_name)
    response = get_flamegraph_response(fg_params, file_type="collapsed_file")
    svg_flamegraph = get_svg_file(response.text)
    return StreamingResponse(svg_flamegraph, media_type=mimetype,
                           headers={"Content-Disposition": f"attachment; filename={svg_file_name}"})
```
- **FastAPI URL normalization**: FastAPI may redirect to normalize URLs
- **HTTP redirect generation**: FastAPI generated `Location: http://...` headers
- **Mixed content error**: Browser blocked HTTP redirects on HTTPS pages

## üåê Where the Error Originates

### Browser Security Policy
- **Origin**: The mixed content error is **generated by the browser**, not FastAPI
- **Security Feature**: Browsers block insecure (HTTP) content on secure (HTTPS) pages
- **Detection**: Browser analyzes response headers, specifically `Location` headers in redirects
- **Enforcement**: Browser prevents the download and shows the error in console

### Error Flow
```
1. Browser makes HTTPS request to download SVG
2. FastAPI responds with HTTP redirect (Location: http://...)
3. Browser detects mixed content violation
4. Browser blocks the request and shows error
5. Download fails
```

## üîß Solution Implementation

### Problem Identification
The issue was in the request flow where FastAPI was unaware of the original HTTPS protocol due to incorrect proxy header handling.

### Fix 1: Nginx Configuration
**File**: `/src/gprofiler/nginx/nginx.conf`

**Before (Incorrect):**
```nginx
location /api {
    proxy_set_header X-Forwarded-Proto $scheme;  # Always "http" since Nginx receives HTTP
    # ... other headers
}
```

**After (Correct):**
```nginx
location /api {
    proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;  # Forwards Envoy's "https"
    # ... other headers
}
```

**Explanation:**
- `$scheme` = protocol of current request to Nginx (always "http" from Envoy)
- `$http_x_forwarded_proto` = value of `X-Forwarded-Proto` header from Envoy ("https")

### Fix 2: Gunicorn Configuration
**File**: `/src/gprofiler/run.sh`

**Before:**
```bash
gunicorn_cmd_line="gunicorn --bind 0.0.0.0:5000 --workers $workers_count ..."
```

**After:**
```bash
gunicorn_cmd_line="gunicorn --bind 0.0.0.0:5000 --workers $workers_count --forwarded-allow-ips=* ..."
```

**Explanation:**
- `--forwarded-allow-ips=*` tells Gunicorn to trust `X-Forwarded-*` headers
- Without this, FastAPI ignores proxy headers for security reasons
- This allows FastAPI to correctly identify the original HTTPS protocol

## üéØ Architecture Overview

### Request Flow (After Fix)
```
Browser (HTTPS) ‚Üí Envoy ‚Üí Nginx ‚Üí FastAPI
                    ‚Üì       ‚Üì       ‚Üì
                 Sets:   Forwards: Reads:
            X-Forwarded- X-Forwarded- X-Forwarded-
            Proto: https Proto: https Proto: https
                                        ‚Üì
                              Generates HTTPS URLs ‚úÖ
```

### Why This Architecture?
1. **SSL Termination**: Envoy handles SSL certificates and HTTPS complexity
2. **Load Balancing**: Envoy distributes traffic across multiple instances
3. **Reverse Proxy**: Nginx handles static files and API routing
4. **Application Server**: FastAPI focuses on business logic
5. **Header Chain**: Each layer forwards protocol information downstream

## üö´ Alternative Solutions Considered

### Could Envoy Fix This by Modifying Response Headers?
**Technically possible but not recommended:**

```yaml
# Hypothetical Envoy config (NOT RECOMMENDED)
response_headers_to_add:
  - header:
      key: "location"
      value: "https://gprofiler.example.com%{REQ(location)}%"
```

**Why this approach is wrong:**
- ‚ùå **Complex**: Requires parsing and rewriting every Location header
- ‚ùå **Fragile**: Breaks when FastAPI changes URL generation
- ‚ùå **Incomplete**: Doesn't fix URLs in response bodies or JSON
- ‚ùå **Performance**: Additional processing overhead
- ‚ùå **Non-standard**: Goes against industry best practices

### The Correct Approach (What We Did)
- ‚úÖ **Standard**: Industry-standard proxy header forwarding
- ‚úÖ **Simple**: One configuration change in each layer
- ‚úÖ **Complete**: Fixes all URL generation, not just redirects
- ‚úÖ **Maintainable**: Follows established patterns
- ‚úÖ **Performant**: No additional processing required

## üìã Verification Steps

### Before Fix
```bash
curl -v "https://gprofiler.example.com/api/flamegraph/download_svg?..."
# Returns: Location: http://gprofiler.example.com/... (HTTP redirect)
```

### After Fix
```bash
curl -v "https://gprofiler.example.com/api/flamegraph/download_svg?..."
# Returns: Location: https://gprofiler.example.com/... (HTTPS redirect)
```

### Browser Verification
1. Open browser developer tools
2. Navigate to Network tab
3. Trigger SVG download
4. Verify no mixed content errors in Console
5. Confirm successful download

## üîë Key Takeaways

1. **Mixed content errors originate from browser security policies**, not the application
2. **Proxy header forwarding is critical** in multi-tier architectures with SSL termination
3. **Both Nginx and Gunicorn configuration** were required for the complete fix
4. **JSON vs SVG behavior difference** was due to redirects vs direct responses
5. **Industry-standard solutions** (header forwarding) are preferred over custom workarounds

## üìö References

- [FastAPI Behind a Proxy Documentation](https://fastapi.tiangolo.com/advanced/behind-a-proxy/)
- [Nginx Proxy Module Documentation](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)
- [Gunicorn Proxy Settings](https://docs.gunicorn.org/en/stable/settings.html#forwarded-allow-ips)
- [Mozilla Mixed Content Documentation](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content)